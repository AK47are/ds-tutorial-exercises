# 练习题6

### Q1:
如何理解数组是线性表的推广？

#### 答案：
数组元素也可以为线性表。比如二维数组，每个元素为一维数组。

---

### Q2:
三维数组 $a[0..7, 0..8, 0..9]$ 采用按行序优先存储，数组的起始地址是 $1000$ ，每个元素占用两字节，试给出下面的结果：
1. 元素 $a_{1, 6, 8}$ 的起始地址。
2. 数组 $a$ 所占用的存储空间。

#### 答案：
1. $1316 = 1000 + 9 * 10 * 2 + 6 * 10 * 2 + 8 * 2$
2. $1440$

---

### Q3:
如果某个一维数组 $A$ 的元素个数 $n$ 很大，存在大量重复的元素，且所有值相同的元素紧挨在一起，请设计一种压缩存储方式使得存储空间更节约。

#### 答案：
每个元素，由数字 + 元素表示。例如 "aaabbbbbbbcddd" = "3a6b1c3d" 。

---

### Q4:
一个 $n$ 阶对称矩阵 $A$ 采用压缩存储在一维数组 $B$ 中，则 $B$ 中包含多少个元素？

#### 答案：
$\frac{n(n + 1)}{2}$

---

### Q5:
设 $n \times n$ 的上三角矩阵 $A[0..n-1, 0..n-1]$ 已压缩到一维数组 $B[0..m]$ 中，若按列为主序存储，则 $A[i][j]$ 对应的 $B$ 中的存储位置 $k$ 为多少？给出推导过程。

#### 答案：
因为是上三角矩阵且按列为主序展开，第一列有 1 个元素存储在数组中，第二列有 2 个, ... ,第 i 列有 i 个, ... , 第 n 列有 n 个。

我可以知道当 $i \ge j$ 时元素在第 $i$ 行的第 $j$ 列，到第 $j$ 列前有 $1 + 2 + ... + j - 1$ 个元素，$k = \frac{(j - 1)j}{2}$。可以计算得 $k = \frac{(j - 1)j}{2} + i$ ，由于数组的 $j$, $i$ 都要小一位，所以还要修正式子得 $k = \frac{j(j + 1)}{2} + i + 1$ ,也就是说是数组 $B$ 第 $k$ 个元素，那么下标自然是 $k - 1 = \frac{j(j + 1)}{2} + i$ 。当 $i < j$ 时将 $j$, $i$ 互换。 

---

### Q6:
利用三元组存储任意稀疏矩阵 $A$ ，假设其中一个元素和一个整数占用地存储空间相同，问在什么条件下才能节省空间。 

#### 答案：
$3(t + 1) < m \times n$ （ $t$ 为非零元素个数，$m, n$ 为矩阵的大小）

---

### Q7:
用十字链表存储一个有 $k$ 个非零元素的 $m \times n$ 的稀疏矩阵，则其总的结点数为多少？

#### 答案：
$Max(m, n) + 1 + k$

---

### Q8:
求下列广义表运算的结果。
1. $head[(x, y, z)]$
2. $tail[((a,b), (x, y))]$

#### 答案：
1. $x$
2. $(x, y)$

---

### Q9:
设有二维整数数组 $B[0..m - 1, 0..n - 1]$ 的数据在行、列方向上都按从小到大的顺序排列，且整数变量 $x$ 中的数据 在 $B$ 中存在，设计一个算法，找出一对满足 $B[i][j] = x$ 的 $i, j$ 值，要求比较次数不超过 $m + n$ 。

#### 答案：
```cpp
void Find(int B[m][n], int x, int i, int j) {
    if (B[i][j] == x) 
      cout << "B[" << i << "][" << j << "] == " << x "\n";
    else if (B[i][j] < x)
      Find(B, x, i + 1, j);
    else
      Find(B, x, i, j - 1);
}
```

---

### Q10:
设计一个算法，计算一个用三元组表表示的稀疏矩阵的对角线元素之和。

#### 答案：
```cpp
int Sum(const TSMatrix& t) {
  int sum = 0;
  for (int i = 0; i < t.nums; ++i) {
    if (t.data[i].r == t.data[i].c) sum += t.data[i].d;
  }
  return sum;
}
```

---

### Q11:
设计一个算法 $Same(g1, g2)$ ，判断两个广义表 $g1$ 和 $g2$ 是否相同。

#### 答案：
```cpp
bool Same(GLNode* g1, GLNode* g2) {
  while (g1 && g2) {
    if (g1->tag != g2->tag) return false;
    if (g1->tag == 0)
      if (g1->data != g2->data) return false;
    else
      if (!Same(g1->sublist, g2->sublist)) return false;
    g1 = g1->next, g2 = g2->next;
  }
  if (g1 || g2) return false;
  return true;
}
```

---
